Kartik P MCS: R1 - MSTeams - 30M
--------------------------------------
1.Tell me about yourself
I am Ali Hussain. Currently, I am working at Modernize Chip Solutions as a software engineer.
I started my career with Lowe's Services India Pvt. Ltd. in Bangalore, and it’s been 2.7 years
 now as a software engineer. In these 2.7 years, I have learned a lot about technologies,
 including my specialisation as a software engineer. I enjoy everything that I do. I am always
 ready to face challenges and get along well with people. I believe in vision and action.
 I learn from my mistakes. I am ready to take on any challenge required to perform my job.

2.Roles and responsibilities
 Involved in client interactions and status meetings
 Involved in implementing code using Python with Django framework
 Interacted with client for Requirement Functional,Technical Analysis,Design and Development
 Implemented test cases using unit test and mock frameworks
 Involved in Code Reviews and Code Refactoring

3.About the Project

Project
Client : CSC Corporation Services Company, USA
Duration : Nov 2020 to till Date
Role : Software Engineer
Project : Entity Management Renewals
Technologies : Python, Django, Mysql, Docker, Bamboo, Bitbucket, Apache Kafka, GIT

Project Description:
As a new application that wants to use the scheduler service, application should go through
process of classifying the attributes. The attributes can be defined at different levels like
Event level ,Schedule level and Schedule instance level attributes. With the events creation
CSC user can create his own events like every first week of every year with time and period.
At event level he can directly cancel the events. At Schedule level, client should verify any
coincidence is happening or not. As an EM user he can create, update, delete the events.

4.Experience in Flask and django(years)
Flask  1.5 years
django 1.2 years

5.List vs Sets
List
The list in Python is like an array of dynamic size, which can be declared in different
languages such as vector in C++ language and ArrayList in Java language. It is not compulsory
for a list in Python to be homogenous, and this characteristic of the list makes it one of
the powerful tools of Python.

The following are the important characteristics of list:

It is the datatype offered by Python. The users can write it as the list whose values can be
separated by a comma and are written between the square brackets.
It can be converted into different data types, and the users can store any element of data
in it. Therefore, the List is mutable.
It is ordered.

Set
Sets are the unordered collection of data types in Python, which are mutable and iterable.
Sets do not have any repetition of identical elements. One of the major advantages of using
sets data storing tool in Python over List is that it offers highly optimized methods for
checking the presence of specific items present in the set.

The following are the important characteristics of set:

It is the unordered collection of items or data types in Python.
The order of elements stored in it is not fixed. The order of set elements can be changed.
A set of elements is defined between curly brackets { }.
Although only immutable elements are stored in sets, it is mutable.

6.Memory Management in python

Understanding Memory allocation is important to any software developer as writing efficient
code means writing a memory-efficient code. Memory allocation can be defined as allocating a
block of space in the computer memory to a program. In Python memory allocation and
deallocation method is automatic as the Python developers created a garbage collector for
Python so that the user does not have to do manual garbage collection.

Garbage Collection

Garbage collection is a process in which the interpreter frees up the memory when not in use
to make it available for other objects.
Assume a case where no reference is pointing to an object in memory i.e. it is not in use so,
the virtual machine has a garbage collector that automatically deletes that object from the
heap memory

Note: For more information, refer to Garbage Collection in Python

Reference Counting
Reference counting works by counting the number of times an object is referenced by other
objects in the system. When references to an object are removed, the reference count for an
object is decremented. When the reference count becomes zero, the object is deallocated.

For example, Let’s suppose there are two or more variables that have the same value, so, what
Python virtual machine does is, rather than creating another object of the same value in the
private heap, it actually makes the second variable point to that originally existing value
in the private heap. Therefore, in the case of classes, having a number of references may
occupy a large amount of space in the memory, in such a case referencing counting is highly
beneficial to preserve the memory to be available for other objects

Example:


x = 10
When x = 10 is executed an integer object 10 is created in memory and its reference is
assigned to variable x, this is because everything is object in Python.

memory-allocation-python-1

Let’s verify if it’s true


x = 10
y = x

if id(x) == id(y):
    print("x and y refer to the same object")
Output:

x and y refer to the same object
In the above example, y = x will create another reference variable y which will refer to the
same object because Python optimizes memory utilization by allocation the same object
reference to a new variable if the object already exists with the same value.

memory-allocation-python-2

Now, let’s change the value of x and see what happens.


x = 10
y = x
x += 1

if id(x) != id(y):
    print("x and y do not refer to the same object")
Output:

x and y do not refer to the same object
So now x refer to a new object x and the link between x and 10 disconnected but y still
refer to 10.

memory-allocation-python-1-1

Memory Allocation in Python
There are two parts of memory:

stack memory
heap memory
The methods/method calls and the references are stored in stack memory and all the values
objects are stored in a private heap.

Work of Stack Memory
The allocation happens on contiguous blocks of memory. We call it stack memory allocation
because the allocation happens in the function call stack. The size of memory to be allocated
is known to the compiler and whenever a function is called, its variables get memory
allocated on the stack.

It is the memory that is only needed inside a particular function or method call. When a
function is called, it is added onto the program’s call stack. Any local memory assignments
such as variable initializations inside the particular functions are stored temporarily on
the function call stack, where it is deleted once the function returns, and the call stack
moves on to the next task. This allocation onto a contiguous block of memory is handled by
the compiler using predefined routines, and developers do not need to worry about it.

Example:


def func():

    # All these variables get memory
    # allocated on stack
    a = 20
    b = []
    c = ""
Work of Heap Memory
The memory is allocated during the execution of instructions written by programmers. Note
that the name heap has nothing to do with the heap data structure. It is called heap because
it is a pile of memory space available to programmers to allocated and de-allocate. The
variables are needed outside of method or function calls or are shared within multiple
functions globally are stored in Heap memory.

Example:


# This memory for 10 integers
# is allocated on heap.
a = [0]*10

7.Pickling and unpickling
Python pickle module is used for serializing and de-serializing python object structures.
The process to converts any kind of python objects (list, dict, etc.) into byte streams
(0s and 1s) is called pickling or serialization or flattening or marshalling. We can
converts the byte stream (generated through pickling) back into python objects by a
process called as unpickling.

Why Pickle?: In real world sceanario, the use pickling and unpickling are widespread as
they allow us to easily transfer data from one server/system to another and then store
it in a file or database.

Precaution: It is advisable not to unpickle data received from an untrusted source as they
may pose security threat. However, the pickle module has no way of knowing or raise alarm
while pickling malicious data.

Only after importing pickle module we can do pickling and unpickling. Importing pickle can
be done using the following command −

import pickle
Pickle examples:

Below is a simple program on how to pickle a list:

Pickle a simple list: Pickle_list1.py

import pickle
mylist = ['a', 'b', 'c', 'd']
with open('datafile.txt', 'wb') as fh:
   pickle.dump(mylist, fh)
In the above code, list – “mylist” contains four elements (‘a’, ‘b’, ‘c’, ‘d’). We open the
file in “wb” mode instead of “w” as all the operations are done using bytes in the current
working directory. A new file named “datafile.txt” is created, which converts the mylist
data in the byte stream.

Unpickle a simple list: unpickle_list1.py

import pickle
pickle_off = open ("datafile.txt", "rb")
emp = pickle.load(pickle_off)
print(emp)
Output: On running above scripts, you can see your mylist data again as output.

['a', 'b', 'c', 'd']
Pickle a simple dictionary −

import pickle
EmpID = {1:"Zack",2:"53050",3:"IT",4:"38",5:"Flipkart"}
pickling_on = open("EmpID.pickle","wb")
pickle.dump(EmpID, pickling_on)
pickling_on.close()
Unpickle a dictionary −

import pickle
pickle_off = open("EmpID.pickle", 'rb')
EmpID = pickle.load(pickle_off)
print(EmpID)
On running above script(unpickle) we get our dictionary back as we initialized earlier.
Also, please note because we are reading bytes here, we have used “rb” instead of “r”.

Output
{1: 'Zack', 2: '53050', 3: 'IT', 4: '38', 5: 'Flipkart'}
Pickle Exceptions
Below are some of the common exceptions raised while dealing with pickle module −

Pickle.PicklingError: If the pickle object doesn’t support pickling, this exception is raised.

Pickle.UnpicklingError: In case the file contains bad or corrupted data.

EOFError: In case the end of file is detected, this exception is raised.

Prons:

Comes handy to save complicated data.

Easy to use, lighter and doesn’t require several lines of code.

The pickled file generated is not easily readable and thus provide some security.

Cons:

Languages other than python may not able to reconstruct pickled python objects.

Risk of unpickling data from malicious sources.


8.Method overloading in python
Like other languages (for example, method overloading in C++) do, python does not support
method overloading by default. But there are different ways to achieve method overloading
in Python.

The problem with method overloading in Python is that we may overload the methods but can
only use the latest defined method.


# First product method.
# Takes two argument and print their
# product
def product(a, b):
    p = a * b
    print(p)

# Second product method
# Takes three argument and print their
# product
def product(a, b, c):
    p = a * b*c
    print(p)

# Uncommenting the below line shows an error
# product(4, 5)

# This line will call the second product method
product(4, 5, 5)
Output:

100
In the above code, we have defined two product method, but we can only use the second product
 method, as python does not support method overloading. We may define many methods of the
 same name and different arguments, but we can only use the latest defined method. Calling
 the other method will produce an error. Like here calling product(4, 5)    will produce an
 error as the latest defined product method takes three arguments.

Thus, to overcome the above problem we can use different ways to achieve the method
overloading.

Method 1 (Not The Most Efficient Method):
We can use the arguments to make the same function work differently i.e. as per the arguments.


# Function to take multiple arguments
def add(datatype, *args):

    # if datatype is int
    # initialize answer as 0
    if datatype =='int':
        answer = 0

    # if datatype is str
    # initialize answer as ''
    if datatype =='str':
        answer =''

    # Traverse through the arguments
    for x in args:

        # This will do addition if the
        # arguments are int. Or concatenation
        # if the arguments are str
        answer = answer + x

    print(answer)

# Integer
add('int', 5, 6)

# String
add('str', 'Hi ', 'G')
Output:

11
Hi G
The problem with above code is that makes code more complex with multiple if/else statement
and is not the desired way to achieve the method overloading.

Method 2 (Efficient One):
By Using Multiple Dispatch Decorator
Multiple Dispatch Decorator Can be installed by:

pip3 install multipledispatch

from multipledispatch import dispatch

#passing one parameter
@dispatch(int,int)
def product(first,second):
    result = first*second
    print(result);

#passing two parameters
@dispatch(int,int,int)
def product(first,second,third):
    result  = first * second * third
    print(result);

#you can also pass data type of any value as per requirement
@dispatch(float,float,float)
def product(first,second,third):
    result  = first * second * third
    print(result);


#calling product method with 2 arguments
product(2,3,2) #this will give output of 12
product(2.2,3.4,2.3) # this will give output of 17.985999999999997
Output:

12
17.985999999999997
In Backend, Dispatcher creates an object which stores different implementation and on
runtime, it selects the appropriate method as the type and number of parameters passed.

9.Class methods and instance methods
Class Variable: A class variable is nothing but a variable that is defined outside the
constructor. A class variable is also called as a static variable.

Accessor(Getters): If you want to fetch the value from an instance variable we call
them accessors.

Mutator(Setters): If you want to modify the value we call them mutators.

1. Instance Method
This is a very basic and easy method that we use regularly when we create classes in python.
If we want to print an instance variable or instance method we must create an object of
that required class.

If we are using self as a function parameter or in front of a variable, that is nothing but
the calling instance itself.

As we are working with instance variables we use self keyword.

Note: Instance variables are used with instance methods.

Look at the code below


# Instance Method Example in Python
class Student:

    def __init__(self, a, b):
        self.a = a
        self.b = b

    def avg(self):
        return (self.a + self.b) / 2

s1 = Student(10, 20)
print( s1.avg() )
Output:

15.0
In the above program, a and b are instance variables and these get initialized when we
create an object for the Student class. If we want to call avg() function which is an
instance method, we must create an object for the class.

If we clearly look at the program, the self keyword is used so that we can easily say that
those are instance variables and methods.

2. Class Method
classsmethod() function returns a class method as output for the given function.

Here is the syntax for it:

classmethod(function)
The classmethod() method takes only a function as an input parameter and converts that
into a class method.

There are two ways to create class methods in python:

Using classmethod(function)

Using @classmethod annotation

A class method can be called either using the class (such as C.f()) or using an instance
(such as C().f()). The instance is ignored except for its class. If a class method is called
from a derived class, the derived class object is passed as the implied first argument.

As we are working with ClassMethod we use the cls keyword. Class variables are used with
class methods.

Look at the code below.

# Class Method Implementation in python
class Student:
    name = 'Student'
    def __init__(self, a, b):
        self.a = a
        self.b = b

    @classmethod
    def info(cls):
        return cls.name

print(Student.info())
Output:

Student
In the above example, name is a class variable. If we want to create a class method we must
use @classmethod decorator and cls as a parameter for that function.

3. Static Method
A static method can be called without an object for that class, using the class name directly.
 If you want to do something extra with a class we use static methods.

For example, If you want to print factorial of a number then we don't need to use class
variables or instance variables to print the factorial of a number. We just simply pass a
number to the static method that we have created and it returns the factorial.

Look at the below code

# Static Method Implementation in python
class Student:
    name = 'Student'
    def __init__(self, a, b):
        self.a = a
        self.b = b

    @staticmethod
    def info():
        return "This is a student class"

print(Student.info())
Output

This is a student class

10.Instance variables can access class variables
Instance attributes are those attributes that are not shared by objects. Every object has its
own copy of the instance attribute i.e. for every object, instance attribute is different.

There are two ways to access the instance variable of class:

Within the class by using self and object reference.
Using getattr() method
Example 1: Using Self and object reference


#creating class
class student:

    # constructor
    def __init__(self, name, rollno):

        # instance variable
        self.name = name
        self.rollno = rollno

    def display(self):

        # using self to access
        # variable inside class
        print("hello my name is:", self.name)
        print("my roll number is:", self.rollno)

# Driver Code
# object created
s = student('HARRY', 1001)

# function call through object
s.display()

# accessing variable from
# outside the class
print(s.name)
Output:

hello my name is: HARRY
my roll number is: 1001
HARRY
Example 2: Using getattr()


# Python code for accessing attributes of class
class emp:
    name='Harsh'
    salary='25000'
    def show(self):
        print(self.name)
        print(self.salary)

# Driver Code
e1 = emp()
# Use getattr instead of e1.name
print(getattr(e1,'name'))

# returns true if object has attribute
print(hasattr(e1,'name'))

# sets an  attribute
setattr(e1,'height',152)

# returns the value of attribute name height
print(getattr(e1,'height'))

# delete the attribute
delattr(emp,'salary')
Output:

Harsh
True
152

11.Append and extend

Append: Adds its argument as a single element to the end of a list. The length of the list
increases by one.

syntax:
# Adds an object (a number, a string or a
# another list) at the end of my_list
my_list.append(object)

my_list = ['geeks', 'for']
my_list.append('geeks')
print my_list
Output:

['geeks', 'for', 'geeks']
NOTE: A list is an object. If you append another list onto a list, the parameter list will
be a single object at the end of the list.


my_list = ['geeks', 'for', 'geeks']
another_list = [6, 0, 4, 1]
my_list.append(another_list)
print my_list
Output:

['geeks', 'for', 'geeks', [6, 0, 4, 1]]


extend(): Iterates over its argument and adding each element to the list and extending the
list. The length of the list increases by number of elements in it’s argument.

syntax:
# Each element of an iterable gets appended
# to my_list
my_list.extend(iterable)

my_list = ['geeks', 'for']
another_list = [6, 0, 4, 1]
my_list.extend(another_list)
print my_list
Output:

['geeks', 'for', 6, 0, 4, 1]
NOTE: A string is an iterable, so if you extend a list with a string, you’ll append each
character as you iterate over the string.


my_list = ['geeks', 'for', 6, 0, 4, 1]
my_list.extend('geeks')
print my_list
Output:

['geeks', 'for', 6, 0, 4, 1, 'g', 'e', 'e', 'k', 's']
Time Complexity:
Append has constant time complexity i.e.,O(1).
Extend has time complexity of O(k). Where k is the length of list which need to be added.


12.Decorators
Decorators are a very powerful and useful tool in Python since it allows programmers to
modify the behaviour of function or class. Decorators allow us to wrap another function in
order to extend the behaviour of the wrapped function, without permanently modifying it. But
before diving deep into decorators let us understand some concepts that will come in handy
in learning the decorators.

First Class Objects
In Python, functions are first class objects that mean that functions in Python can be used
or passed as arguments.
Properties of first class functions:
A function is an instance of the Object type.
You can store the function in a variable.
You can pass the function as a parameter to another function.
You can return the function from a function.
You can store them in data structures such as hash tables, lists, …
Consider the below examples for better understanding.

Example 1: Treating the functions as objects.


# Python program to illustrate functions
# can be treated as objects
def shout(text):
    return text.upper()

print(shout('Hello'))

yell = shout

print(yell('Hello'))
Output:

HELLO
HELLO
In the above example, we have assigned the function shout to a variable. This will not call
the function instead it takes the function object referenced by a shout and creates a second
name pointing to it, yell.

Example 2: Passing the function as an argument


# Python program to illustrate functions
# can be passed as arguments to other functions
def shout(text):
    return text.upper()

def whisper(text):
    return text.lower()

def greet(func):
    # storing the function in a variable
    greeting = func("""Hi, I am created by a function passed as an argument.""")
    print (greeting)

greet(shout)
greet(whisper)
Output:

HI, I AM CREATED BY A FUNCTION PASSED AS AN ARGUMENT.
hi, i am created by a function passed as an argument.
In the above example, the greet function takes another function as a parameter (shout and
whisper in this case). The function passed as an argument is then called inside the
function greet.

Example 3: Returning functions from another function.


# Python program to illustrate functions
# Functions can return another function

def create_adder(x):
    def adder(y):
        return x+y

    return adder

add_15 = create_adder(15)

print(add_15(10))
Output:

25
In the above example, we have created a function inside of another function and then have
returned the function created inside.
The above three examples depict the important concepts that are needed to understand
decorators. After going through them let us now dive deep into decorators.

Decorators
As stated above the decorators are used to modify the behaviour of function or class. In
Decorators, functions are taken as the argument into another function and then called inside
the wrapper function.

Syntax for Decorator:

@gfg_decorator
def hello_decorator():
    print("Gfg")

'''Above code is equivalent to -

def hello_decorator():
    print("Gfg")

hello_decorator = gfg_decorator(hello_decorator)'''
In the above code, gfg_decorator is a callable function, will add some code on the top of
some another callable function, hello_decorator function and return the wrapper function.

Decorator can modify the behaviour:


# defining a decorator
def hello_decorator(func):

    # inner1 is a Wrapper function in
    # which the argument is called

    # inner function can access the outer local
    # functions like in this case "func"
    def inner1():
        print("Hello, this is before function execution")

        # calling the actual function now
        # inside the wrapper function.
        func()

        print("This is after function execution")

    return inner1


# defining a function, to be called inside wrapper
def function_to_be_used():
    print("This is inside the function !!")


# passing 'function_to_be_used' inside the
# decorator to control its behaviour
function_to_be_used = hello_decorator(function_to_be_used)


# calling the function
function_to_be_used()
Output:

Hello, this is before function execution
This is inside the function !!
This is after function execution
Let’s see the behaviour of the above code how it runs step by step when the
“function_to_be_used” is called.




Let’s jump to another example where we can easily find out the execution time of a function
using a decorator.


# importing libraries
import time
import math

# decorator to calculate duration
# taken by any function.
def calculate_time(func):

    # added arguments inside the inner1,
    # if function takes any arguments,
    # can be added like this.
    def inner1(*args, **kwargs):

        # storing time before function execution
        begin = time.time()

        func(*args, **kwargs)

        # storing time after function execution
        end = time.time()
        print("Total time taken in : ", func.__name__, end - begin)

    return inner1



# this can be added to any function present,
# in this case to calculate a factorial
@calculate_time
def factorial(num):

    # sleep 2 seconds because it takes very less time
    # so that you can see the actual difference
    time.sleep(2)
    print(math.factorial(num))

# calling the function.
factorial(10)
Output:

3628800
Total time taken in :  factorial 2.0061802864074707
What if a function returns something or an argument is passed to the function?
In all the above examples the functions didn’t return anything so there wasn’t any issue,
but one may need the returned value.


def hello_decorator(func):
    def inner1(*args, **kwargs):

        print("before Execution")

        # getting the returned value
        returned_value = func(*args, **kwargs)
        print("after Execution")

        # returning the value to the original frame
        return returned_value

    return inner1


# adding decorator to the function
@hello_decorator
def sum_two_numbers(a, b):
    print("Inside the function")
    return a + b

a, b = 1, 2

# getting the value through return of the function
print("Sum =", sum_two_numbers(a, b))
Output:

before Execution
Inside the function
after Execution
Sum = 3
In the above example, you may notice a keen difference in the parameters of the inner
function. The inner function takes the argument as *args and **kwargs which means that a
tuple of positional arguments or a dictionary of keyword arguments can be passed of any
length. This makes it a general decorator that can decorate a function having any number
of arguments.

Chaining Decorators
In simpler terms chaining decorators means decorating a function with multiple decorators.

Example:


# code for testing decorator chaining
def decor1(func):
    def inner():
        x = func()
        return x * x
    return inner

def decor(func):
    def inner():
        x = func()
        return 2 * x
    return inner

@decor1
@decor
def num():
    return 10

print(num())
Output:

400
The above example is similar to calling the function as –

decor1(decor(num))

13.Call by refrence and call by value
Python utilizes a system, which is known as “Call by Object Reference” or “Call by assignment”.
In the event that you pass arguments like whole numbers, strings or tuples to a function, the
passing is like call-by-value because you can not change the value of the immutable objects
being passed to the function. Whereas passing mutable objects can be considered as call by
reference because when their values are changed inside the function, then it will also be
reflected outside the function.
Example 1:



# Python code to demonstrate
# call by value


string = "Geeks"


def test(string):

    string = "GeeksforGeeks"
    print("Inside Function:", string)

# Driver's code
test(string)
print("Outside Function:", string)
Output


Inside Function: GeeksforGeeks
Outside Function: Geeks
Example 2



# Python code to demonstrate
# call by reference


def add_more(list):
    list.append(50)
    print("Inside Function", list)

# Driver's code
mylist = [10,20,30,40]

add_more(mylist)
print("Outside Function:", mylist)
Output


Inside Function [10, 20, 30, 40, 50]
Outside Function: [10, 20, 30, 40, 50]


Binding Names to Objects
In python, each variable to which we assign a value/container is treated as an object. When
we are assigning a value to a variable, we are actually binding a name to an object.



a = "first"
b = "first"


# Returns the actual location
# where the variable is stored
print(id(a))

# Returns the actual location
# where the variable is stored
print(id(b))

# Returns true if both the variables
# are stored in same location
print(a is b)
Output


110001234557894
110001234557894
True
Now, let’s try and understand this better with another example.
Example 2:



a = [10, 20, 30]
b = [10, 20, 30]

# return the location
# where the variable
# is stored
print(id(a))

# return the location
# where the variable
# is stored
print(id(b))

# returns false if the
# location is not same
print(a is b)
Output


541190289536222
541190288737777
False
The output of the above two examples are different because the list is mutable and the
string is immutable. An immutable variable cannot be changed once created. If we wish to
change an immutable variable, such as a string, we must create a new instance and bind the
variable to the new instance. Whereas, mutable variable can be changed in place.
Example 3:



def foo(a):

    # A new variable is assigned
    # for the new string
    a = "new value"
    print("Inside Function:", a)


# Driver's code
string = "old value"
foo(string)

print("Outside Function:", string)
Output:


Inside Function: new value
Outside Function: old value
In the above example, a string which is an immutable type of object is passed as argument
to the function foo. Within the scope of the given function foo, a= “new value” has been
bounded to the same object that string has been bound outside. Within the scope of the
function foo, we modify “old value”` to “new value”. Once we leave the scope of function
foo , a=”new value” is no longer in the name space, and the value that string refers to
was never changed.
Example 4: Now, let us look at how mutable variable is passed into the function.



def foo(a):
    a[0] = "Nothing"

# Driver' code
bar = ['Hi', 'how', 'are', 'you', 'doing']
foo(bar)
print(bar)
Output:


['Nothing, 'how', 'are', 'you', 'doing']
When we pass a mutable variable into the function foo and modify it to some other name the
function foo still points to that object and continue to point to that object during its
execution.

14.Shallow copy and Deep copy
In Python, Assignment statements do not copy objects, they create bindings between a target
and an object. When we use = operator user thinks that this creates a new object; well, it
doesn’t. It only creates a new variable that shares the reference of the original object.
Sometimes a user wants to work with mutable objects, in order to do that user looks for a
way to create “real copies” or “clones” of these objects. Or, sometimes a user wants copies
that user can modify without automatically modifying the original at the same time, in order
to do that we create copies of objects.

A copy is sometimes needed so one can change one copy without changing the other. In Python,
there are two ways to create copies :

Deep copy
Shallow copy
In order to make these copy, we use copy module. We use copy module for shallow and deep
copy operations. For Example

# importing copy module
import copy

# initializing list 1
li1 = [1, 2, [3,5], 4]


# using copy for shallow copy
li2 = copy.copy(li1)

# using deepcopy for deepcopy
li3 = copy.deepcopy(li1)
In the above code, the copy() returns a shallow copy of list and deepcopy() return a deep
copy of list.

Deep copy
Deep copy is a process in which the copying process occurs recursively. It means first
constructing a new collection object and then recursively populating it with copies of
the child objects found in the original. In case of deep copy, a copy of object is copied
in other object. It means that any changes made to a copy of object do not reflect in the
original object. In python, this is implemented using “deepcopy()” function.


# Python code to demonstrate copy operations

# importing "copy" for copy operations
import copy

# initializing list 1
li1 = [1, 2, [3,5], 4]

# using deepcopy to deep copy
li2 = copy.deepcopy(li1)

# original elements of list
print ("The original elements before deep copying")
for i in range(0,len(li1)):
    print (li1[i],end=" ")

print("\r")

# adding and element to new list
li2[2][0] = 7

# Change is reflected in l2
print ("The new list of elements after deep copying ")
for i in range(0,len( li1)):
    print (li2[i],end=" ")

print("\r")

# Change is NOT reflected in original list
# as it is a deep copy
print ("The original elements after deep copying")
for i in range(0,len( li1)):
    print (li1[i],end=" ")
Output:

The original elements before deep copying
1 2 [3, 5] 4
The new list of elements after deep copying
1 2 [7, 5] 4
The original elements after deep copying
1 2 [3, 5] 4
In the above example, the change made in the list did not effect in other lists, indicating
the list is deep copied.


Shallow copy
Shallow
A shallow copy means constructing a new collection object and then populating it with
references to the child objects found in the original. The copying process does not
recurse and therefore won’t create copies of the child objects themselves. In case of
shallow copy, a reference of object is copied in other object. It means that any changes
made to a copy of object do reflect in the original object. In python, this is implemented
using “copy()” function.


# Python code to demonstrate copy operations

# importing "copy" for copy operations
import copy

# initializing list 1
li1 = [1, 2, [3,5], 4]

# using copy to shallow copy
li2 = copy.copy(li1)

# original elements of list
print ("The original elements before shallow copying")
for i in range(0,len(li1)):
    print (li1[i],end=" ")

print("\r")

# adding and element to new list
li2[2][0] = 7

# checking if change is reflected
print ("The original elements after shallow copying")
for i in range(0,len( li1)):
    print (li1[i],end=" ")
Output:

The original elements before shallow copying
1 2 [3, 5] 4
The original elements after shallow copying
1 2 [7, 5] 4
In the above example, the change made in the list did effect in other list, indicating the
list is shallow copied.

Important Points:
The difference between shallow and deep copying is only relevant for compound objects
(objects that contain other objects, like lists or class instances):

A shallow copy constructs a new compound object and then (to the extent possible) inserts
references into it to the objects found in the original.
A deep copy constructs a new compound object and then, recursively, inserts copies into it
of the objects found in the original.

15.Circular Import
What is a Circular Dependency?
A circular dependency occurs when two or more modules depend on each other. This is due to
the fact that each module is defined in terms of the other.

For example:

functionA():
    functionB()
And

functionB():
    functionA()

The code above depicts a fairly obvious circular dependency. functionA() calls functionB(),
thus depending on it, and functionB() calls functionA(). This type of circular dependency
has some obvious problems, which we'll describe a bit further in the next section.

Problems with Circular Dependencies
Circular dependencies can cause quite a few problems in your code. For example, it may
generate tight coupling between modules, and as a consequence, reduced code reusability.
This fact also makes the code more difficult to maintain in the long run.

In addition, circular dependencies can be the source of potential failures, such as
infinite recursions, memory leaks, and cascade effects. If you're not careful and you
have a circular dependency in your code, it can be very difficult to debug the many
potential problems it causes.

What is a Circular Import?
Circular importing is a form of circular dependency that is created with the import
statement in Python.

For example, let's analyze the following code:

# module1
import module2

def function1():
    module2.function2()

def function3():
    print('Goodbye, World!')
# module2
import module1

def function2():
    print('Hello, World!')
    module1.function3()
# __init__.py

import module1

module1.function1()
When Python imports a module, it checks the module registry to see if the module was
already imported. If the module was already registered, Python uses that existing object
from cache. The module registry is a table of modules that have been initialized and indexed
by module name. This table can be accessed through sys.modules.


If it was not registered, Python finds the module, initializes it if necessary, and executes it in the new module's namespace.

In our example, when Python reaches import module2, it loads and executes it. However, module2 also calls for module1, which in turn defines function1().

The problem occurs when function2() tries to call module1's function3(). Since module1 was loaded first, and in turn loaded module2 before it could reach function3(), that function isn't yet defined and throws an error when called:

$ python __init__.py
Hello, World!
Traceback (most recent call last):
  File "__init__.py", line 3, in <module>
    module1.function1()
  File "/Users/scott/projects/sandbox/python/circular-dep-test/module1/__init__.py", line 5, in function1
    module2.function2()
  File "/Users/scott/projects/sandbox/python/circular-dep-test/module2/__init__.py", line 6, in function2
    module1.function3()
AttributeError: 'module' object has no attribute 'function3'
How to Fix Circular Dependencies
In general, circular imports are the result of bad designs. A deeper analysis of the program could have concluded that the dependency isn't actually required, or that the depended functionality can be moved to different modules that wouldn't contain the circular reference.

A simple solution is that sometimes both modules can just be merged into a single, larger module. The resulting code from our example above would look something like this:

# module 1 & 2

def function1():
    function2()

def function2():
    print('Hello, World!')
    function3()

def function3():
    print('Goodbye, World!')

function1()
However, the merged module may have some unrelated functions (tight coupling) and could become very large if the two modules already have a lot code in them.

So if that doesn't work, another solution could have been to defer the import of module2 to import it only when it is needed. This can be done by placing the import of module2 within the definition of function1():

# module 1

def function1():
    import module2
    module2.function2()

def function3():
    print('Goodbye, World!')
16.Avoid circular import
17.Generator and Iterator
18._init.py_ uses
19.Method resolution order
20.how import works
21.Django vs Flask
22.Middleware
23.Signals in django
24.gunicorn in mongodb
25.Mongodb wth django
26.make migrations
27.migrate
28.allowed_host in settings.py
29.authentication in flask and django

Karthikeyan MCS: Round 2 :Interview Questions:
1.roles and responsibilities
2.Django vs flask 8/10
3.flask vs Django
4.create rest api in Django
5.exception handling in flask
6.db conneciton in flask
7.authenitication in falsk
8.get vs filter in django
9.django authentication
10.authitnication vs authoization
11.check authorization in djang
12.token based in rest api
13.serlizers in django
14.singanls in django
15.decorators in django
16.acid in django
17.queue based system kafka
18.micro services in flask
19.deployemnt in projects
20.max salary of each department in sql
21.indexing in sql
22.template in djagno dashboard

Karthick Raja Mcs: Round 1 interview questions
The Questions
1.Roles and Responsibilities
2.Instance Variable
3.Static Variable
4.Class Variable
5.Pickling and Unpickling
6.diff between Django and Flask
7.List Vs Set
8.Diff Between Append() and Extend() in List
9.Shallow Copy and Deep Copy
10. Diff Between Iterator vs Generator
11.Is Python Call by Value or Call By Reference
12.Middleware Classes in Django
13.Signals in Django
14.why django is a full stack Web framework
15.Diff Between  migrate and make migrations
16.what is Allowed_Hosts in  Django
17.what is NoSQL Database
18.diff between union and union all in SQL Query
19.sessions in Django
20.architechture of Django
21.Jinja2 Template
22. Decorators in python
23.Oops Comcepts

Bhavesh MCS: Round 1
--------------
1. roles and responsibilities
2. oops concepts
3. encapsulation abstraction inheritance polymorphism
4. list vs tuple
5. shallow copy vs deep copy
6. blueprint in flask
7. sqlAlchemy